#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

// An 'option code' to determine what the thread function will do when run. Set via the main process.
// 1 - Generate f1.
// 2 - Quit.
char* message;

// Keep track of the current random number generated by each thread, as well as each thread's score.
int* thread_curr_rand_numbers;
int* thread_scores;

/*
 * Struct to keep track of necessary random parameters. Passed into each thread
 * and used as parameters for f1().
 *
 * @param thread_num - used to keep track of which thread we're running.
 * @param x - The Previous randomly generated number
 * @param a - A user-defined constant.
 * @param c - A user-defined constant.
 * @param m - A user-defined constant.
 */
struct RandParams {
    int thread_num;
    int a;
    int c;
    int m;
    int x0;
};

/*
 * f1 - A function used to generate pseudorandom numbers.
 *
 * @param x - The Previous randomly generated number
 * @param a - A user-defined constant.
 * @param c - A user-defined constant.
 * @param m - A user-defined constant.
 * @return - An integer denoting the next pseudorandom number.
 */
int  f1(int x, int a, int c, int m) {
    long int x1 = x * a + c;
    return (int)(x1 % m);
}

/*
 * The thread function. Called upon thread creation. Option codes dictate which action each thread performs.
 * op1 - call f1() with rand_param values (passed in as param).
 * op2 -
 *
 * @param param - a RandParam struct which contains thread_num (keeping track of scoring and number generation) and
 *                a, c, m, x0 (f1 parameters).
 * @return x1 - the number generated by f1().
 */
void* runner(void* param) {

    struct RandParams* rand_params = (struct RandParams*)param;
    int curr_x = rand_params->x0;

    // TODO: Create logic for waiting for the main process' message.

    // As long as the main process doesn't quit the thread...
    while (strcmp(message,"quit") != 0) {
        // Generate the next number, then store it in thread_curr_rand_numbers.
        curr_x = f1(curr_x, rand_params->a, rand_params->c, rand_params->m);
        thread_curr_rand_numbers[rand_params->thread_num] = curr_x;
        printf("DEBUG - Thread %d generated number %d\n",rand_params->thread_num,curr_x);
        sleep(1);
        // TODO: REMOVE DEBUG BREAK STATEMENT
        break;
    }

    // When message has been set to quit, we can exit.
    pthread_exit(0);
}

/*
 * TODO: Update score_round description
 *
 */
void score_round(int num_threads) {

    int min = thread_curr_rand_numbers[0];
    int max = thread_curr_rand_numbers[1];
    int smallest_thread_idx = 0;
    int largest_thread_idx = 0;
    // Keep track of the thread_num with the smallest and largest number.
    for (int i = 1; i < num_threads; i++) {
        // Keeping track of smallest number.
        if (thread_curr_rand_numbers[i] < min) {
            smallest_thread_idx = i;
            min = thread_curr_rand_numbers[smallest_thread_idx];
        }
        // If the current random number is equal to min, there's a chance it may be a tie.
        // Set index out of bounds until we find a new smaller value (or not).
        else if (thread_curr_rand_numbers[i] == min) {
            smallest_thread_idx = -1;
        }

        // Keeping track of largest number.
        if (thread_curr_rand_numbers[i] > max) {
            largest_thread_idx = i;
            max = thread_curr_rand_numbers[largest_thread_idx];
        }
        // If the current random number is equal to max, there's a chance it may be a tie.
        // Set index out of bounds until we find a new larger value (or not).
        else if (thread_curr_rand_numbers[i] == max) {
            largest_thread_idx = -1;
        }
    }
    // Award 1 point to the smallest and largest random number.
    // Only award a point if there is no tie.
    if (largest_thread_idx >= 0) {
        thread_scores[largest_thread_idx]++;
    }
    if (smallest_thread_idx >= 0) {
        thread_scores[smallest_thread_idx]++;
    }
}

/*
 * TODO: Update create_and_run_threads description
 *
 */
void create_and_run_threads(FILE* fp) {

    int num_threads = 0;
    int num_rounds = 0;

    // Read the first line of the file. (Get # of threads to create and # of rounds to score)
    fscanf(fp, "%d", &num_threads);
    fscanf(fp, "%d", &num_rounds);

    // Dynamically allocate global arrays
    thread_curr_rand_numbers = (int*)malloc(sizeof(int) * num_threads);
    thread_scores = (int*)malloc(sizeof(int) * num_threads);

    message = "wait";

    // Store tids and rand parameters for each thread.
    // tids - used for pthread_join after rounds are complete.
    // rand_params - passes thread_num,a,c,m,x0 into thread runner function.
    pthread_t tids[num_threads];
    struct RandParams rand_params[num_threads];

    // Create each thread.
    for (int i = 0; i < num_threads; i++) {

        int thread_num = i;

        // Read in initial values for the thread, and store as a RandParams struct.
        int a, c, m, x0;
        fscanf(fp, "%d", &a);
        fscanf(fp, "%d", &c);
        fscanf(fp, "%d", &m);
        fscanf(fp, "%d", &x0);

        rand_params[i] = {thread_num, a, c, m, x0};

        // Create a new thread, passing in rand_params as the parameter.
        pthread_t tid;
        pthread_attr_t attr;
        pthread_attr_init(&attr);

        pthread_create(&tid, &attr, runner, &rand_params[i]);

        // Store the tid in the tids array for pthread_join (called after rounds are scored).
        tids[i] = tid;
    }
    // For each round...
    for (int rnd = 0; rnd < num_rounds; rnd++) {
        printf("Main process start round %d\n",rnd);
        message = "generate";
        score_round(num_threads);
    }
    // Set message to quit, then wait for all threads to end.
    message = "quit";
    for (int i = 0; i < num_threads; i++) {
        pthread_join(tids[i],NULL);
    }
}

/*
 * Main function -- reads the file and scores the round.
 *
 * @param argc - Number of command-line arguments.
 * @param argv -
 */
int main(int argc, char** argv) {

    if (argc <= 1) {
        printf("ERROR - NO FILE ARGUMENT DETECTED\n");
    } else {
        FILE *fp;

        int i;

        // TODO: ADD ERROR HANDLING IF THE FILE NAME DOES NOT EXIST.
        fp = fopen(argv[1],"r");

        if (fp != NULL) {
            create_and_run_threads(fp);
        } else {
            printf("ERROR - FILE NAME DOES NOT EXIST\n");
        }

        fclose(fp);
    }

    return 0;
}
